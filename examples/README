lib6502 - 6502 Microprocessor Emulator

EXAMPLES

  This file has three sections:

    1. PROGRAMS that you can compile and run
    2. COMMANDS that you can copy and paste into a terminal
    3. ADVANCED stuff that requires some additional setup

  A few numbered footnotes appear at the end and are referenced in the
  text in square brackets [6].

----------------------------------------------------------------

1.  PROGRAMS

  (We're going to start in 'serious mode'.  Bear with me.)

  The file 'lib1.c' contains the example from the u6502 manual page.
  Just compile and run it:

        cc -o lib1 lib1.c
        ./lib1

  The file has been commented extensively to explain exactly what is
  going on.

----------------------------------------------------------------

2.  COMMANDS

  (Much more fun: this is the section that appeals to the geek in me.)

  6502 machine code is pretty straightforward.  (Many 6502 programmers
  remember a time from their misguided childhood when they could
  compose and edit programs directly in hexadecimal using their 'front
  panel' monitor program -- the next best thing to programming with a
  row of switches and lamps, but I digress and will leave that story
  until the pdp11 emulator is ready. ;-)  We can use this fact to
  generate an entire program without needing an assembler.  The 'perl'
  program is available on most Unixy (and several other) systems and
  makes it easy to create binary files from a string of hex digits.
  (There is a program called 'xxd' that's very good at this kind of
  thing, but you might not have it.)

  First the program (stolen from lib1.c):

        1000    ldx #41         A241
        1002    txa             8A
        1003    jsr FFEE        20EEFF
        1006    inx             E8
        1007    cpx #5B         E05B
        1009    bne 1002        D0F7
        100B    lda #0A         A90A
        100D    jsr FFEE        20EEFF
        1010    brk             00

  In C-like syntax it is equivalent to:

        regX = 'A';
        do {
          regA = regX;
          putchar(regA);
        } while (regX != 'Z' + 1);
        putchar('\n');

  (which by today's standards is a *huge* amount of stuff packed into
  just 17 bytes of 'compiled' code -- on a 386 the same program is
  around 65 bytes [1], and more like 88 bytes on a 32-bit RISC [2]).

  The column on the right is the machine code in hexadecimal.  When
  strung out in a line it looks like this:

        A2418A20EEFFE8E05BD0F7A90A20EEFF00

  We can tell perl to 'pack' this hexadecimal string into binary and
  save the output in a file:

        echo A2418A20EEFFE8E05BD0F7A90A20EEFF00 |
        perl -e 'print pack "H*",<STDIN>' > temp.img

  Google for "6502 Reference Card" (with the quotes), grab a pencil
  and paper, and you can start writing 6502 programs immediately!

  If you really start liking this and want to write longer programs in
  text files with the hex split over many lines, you'll need a perl
  script that can deal with newlines in the input.  Something like
  this should do the trick...

        #!/usr/bin/perl

        while (<STDIN>) {
          chomp;
          print pack "H*", $_
        }

  (This script is included in the 'examples' directory, in a file
  called 'hex2bin', to save you 15 seconds of copy and paste.)

  Need a fun project?  Write a 6502 assembler... in 6502 machine code,
  of course!  Read in the assembly language text via 'getchar' and write out
  the assembled binary via 'putchar'.

----------------------------------------------------------------

FOOTNOTES


[1] Here is the 'alphabet' program, verbatim, compiled (with
    optimisation) on a 386.  It's 66 bytes long, almost four times
    longer than the 6502 version.  (If I were more generous I might
    consider that fair: 32 bits divided by 8 bits is four.)

       0:   55                      push   %ebp
       1:   89 e5                   mov    %esp,%ebp
       3:   53                      push   %ebx
       4:   83 ec 14                sub    $0x14,%esp
       7:   bb 41 00 00 00          mov    $0x41,%ebx
       c:   a1 00 00 00 00          mov    0x0,%eax
      11:   89 44 24 04             mov    %eax,0x4(%esp)
      15:   89 1c 24                mov    %ebx,(%esp)
      18:   e8 fc ff ff ff          call   19 <fputc>
      1d:   43                      inc    %ebx
      1e:   83 fb 5b                cmp    $0x5b,%ebx
      21:   75 e9                   jne    c <prog+0xc>
      23:   a1 00 00 00 00          mov    0x0,%eax
      28:   89 44 24 04             mov    %eax,0x4(%esp)
      2c:   c7 04 24 0a 00 00 00    movl   $0xa,(%esp)
      33:   e8 fc ff ff ff          call   34 <fputc>
      38:   b8 00 00 00 00          mov    $0x0,%eax
      3d:   83 c4 14                add    $0x14,%esp
      40:   5b                      pop    %ebx
      41:   5d                      pop    %ebp
      42:   c3                      ret    


[2] Here is the 'alphabet' program, verbatim, compiled (with
    optimisation) on a PowerPC.  It's 88 bytes long, more than five
    times longer than the 6502 version.  (I don't care what you say:
    Apple Macs rule and mine has oodles of RAM to spare.)

    00000000        mfspr   r0,lr
    00000004        stmw    r29,0xfff4(r1)
    00000008        stw     r0,0x8(r1)
    0000000c        stwu    r1,0xffb0(r1)
    00000010        bcl     20,31,0x14
    00000014        mfspr   r31,lr
    00000018        li      r30,0x41
    0000001c        addis   r2,r31,ha16(0xa4-0x14)
    00000020        lwz     r29,lo16(0xa4-0x14)(r2)
    00000024        or      r3,r30,r30
    00000028        addi    r4,r29,0x58
    0000002c        bl      0x7c    ; symbol stub for: _fputc
    00000030        cmpwi   cr7,r30,0x5a
    00000034        addi    r30,r30,0x1
    00000038        bne     cr7,0x24
    0000003c        li      r3,0xa
    00000040        bl      0x5c    ; symbol stub for: _fputc
    00000044        li      r3,0x0
    00000048        lwz     r0,0x58(r1)
    0000004c        addi    r1,r1,0x50
    00000050        mtspr   lr,r0
    00000054        lmw     r29,0xfff4(r1)
    00000058        blr

[3] There is no footnote 3.
